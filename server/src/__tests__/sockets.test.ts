// Tests generated by Claude/ChatGPT, then manually unbroken.

import { type Context } from 'hono';
import { Server as SocketIOServer } from 'socket.io';
import { afterEach, beforeEach, describe, expect, it, type Mock, vi } from 'vitest';
import ioMiddleware, { initWebsocket } from '../shared/middleware/sockets.ts';

// Mock socket.io.
vi.mock('socket.io', () => {
	const fakeIO = { fake: true };
	const MockServer = vi.fn().mockImplementation(function () {
		return {
			on: vi.fn(),
			...fakeIO,
		};
	});

	return {
		Server: MockServer,
	};
});

describe('WebSocket Middleware', () => {
	let mockServer: any;
	let mockContext: any;
	let mockNext: any;

	beforeEach(() => {
		vi.clearAllMocks();

		// Setup mock HTTP server.
		mockServer = {
			listen: vi.fn(),
			close: vi.fn(),
		};

		// Setup mock Hono context.
		mockContext = {
			var: {},
			set: vi.fn((key: string, value: any) => {
				mockContext.var[key] = value;
			}),
			get: vi.fn((key: string) => mockContext.var[key]),
		} as unknown as Context;

		mockNext = vi.fn().mockResolvedValue(undefined);

		process.env.CLIENT_PORT = '3000';
	});

	afterEach(() => {
		delete process.env.CLIENT_PORT;
	});

	describe('initWebsocket', () => {
		it('should initialize Socket.IO server with correct configuration', () => {
			initWebsocket(mockServer);

			expect(SocketIOServer).toHaveBeenCalledWith(mockServer, {
				path: '/ws',
				serveClient: false,
				cors: {
					origin: 'http://localhost:3000',
				},
			});
		});

		it('should register error handler', () => {
			initWebsocket(mockServer);

			const SocketIOConstructor = SocketIOServer as unknown as Mock;
			const mockIOInstance = SocketIOConstructor.mock.results[0].value;

			expect(mockIOInstance.on).toHaveBeenCalledWith('error', expect.any(Function));
		});

		it('should log errors when error handler is called', () => {
			const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

			initWebsocket(mockServer);

			const SocketIOConstructor = SocketIOServer as unknown as Mock;
			const mockIOInstance = SocketIOConstructor.mock.results[0].value;
			const errorHandler = mockIOInstance.on.mock.calls.find(
				(call: any[]) => call[0] === 'error',
			)[1];

			const testError = new Error('Test error');
			errorHandler(testError);

			expect(consoleErrorSpy).toHaveBeenCalledWith(testError);

			consoleErrorSpy.mockRestore();
		});

		it('should use CLIENT_PORT from environment variable', () => {
			process.env.CLIENT_PORT = '8080';

			initWebsocket(mockServer);

			expect(SocketIOServer).toHaveBeenCalledWith(
				mockServer,
				expect.objectContaining({
					cors: {
						origin: 'http://localhost:8080',
					},
				}),
			);
		});
	});

	describe('ioMiddleware', () => {
		it('should set io instance in context when not already set', async () => {
			initWebsocket(mockServer);

			const SocketIOConstructor = SocketIOServer as unknown as Mock;
			const mockIOInstance = SocketIOConstructor.mock.results[0].value;

			await ioMiddleware(mockContext, mockNext);

			expect(mockContext.set).toHaveBeenCalledWith('io', mockIOInstance);
			expect(mockNext).toHaveBeenCalled();
		});

		it('should not set io instance if already present in context', async () => {
			const existingIO = { existing: true };
			mockContext.var.io = existingIO;

			initWebsocket(mockServer);

			await ioMiddleware(mockContext, mockNext);

			expect(mockContext.set).not.toHaveBeenCalled();
			expect(mockNext).toHaveBeenCalled();
		});

		it('should handle async next function', async () => {
			const asyncNext = vi.fn().mockResolvedValue('result');

			initWebsocket(mockServer);

			await ioMiddleware(mockContext, asyncNext);

			expect(asyncNext).toHaveBeenCalled();
		});

		it('should propagate errors from next function', async () => {
			const error = new Error('Next error');
			const errorNext = vi.fn().mockRejectedValue(error);

			initWebsocket(mockServer);

			await expect(ioMiddleware(mockContext, errorNext)).rejects.toThrow('Next error');
		});
	});

	describe('Integration', () => {
		it('should allow middleware to work with initialized socket', async () => {
			initWebsocket(mockServer);

			const SocketIOConstructor = SocketIOServer as unknown as Mock;
			const mockIOInstance = SocketIOConstructor.mock.results[0].value;

			await ioMiddleware(mockContext, mockNext);

			// Verify sockets are accessible.
			expect(mockContext.var.io).toBe(mockIOInstance);
			expect(mockNext).toHaveBeenCalled();
		});

		it('should handle multiple middleware calls', async () => {
			initWebsocket(mockServer);

			const SocketIOConstructor = SocketIOServer as unknown as Mock;
			const mockIOInstance = SocketIOConstructor.mock.results[0].value;

			await ioMiddleware(mockContext, mockNext);
			expect(mockContext.var.io).toBe(mockIOInstance);

			// Second call with same context.
			const mockContext2 = { ...mockContext, set: vi.fn() };
			await ioMiddleware(mockContext2, mockNext);

			expect(mockContext2.set).not.toHaveBeenCalled();
		});
	});
});
